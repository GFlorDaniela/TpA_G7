#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <SPIFFS.h>
#include <ArduinoJson.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <PubSubClient.h>

// OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SH1106G display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// Pines del Encoder F√≠sico
#define ENCODER_CLK 18
#define ENCODER_DT 5  
#define ENCODER_SW 19
#define LED_PIN 23

// WiFi y Telegram
const char *ssid = "FiberteWiFi 871 2.4GHz";
const char *password = "00420317083";
const String BOT_TOKEN = "8499799877:AAFrKrXnz7mkbJlnY6zNcUCdD-oG9UM_uIY";
const String CHAT_ID = "1307295110";

// Clients
WiFiClientSecure secureClient;
UniversalTelegramBot bot(BOT_TOKEN, secureClient);
WiFiClient clientMQTT;

// --- Configuraci√≥n de MQTT ---
const char* mqtt_server = "test.mosquitto.org"; 
const int mqtt_port = 1883;
const char* mqtt_client_id = "esp32-file-sync"; // Un nombre √∫nico para la placa ESP32
PubSubClient client(clientMQTT);

// Estructuras de datos
struct Pregunta {
  String texto;
  String opciones[3];
  int respuestaCorrecta;
  int puntaje;
};

struct Usuario {
  String nombre;
  int puntuacionMaxima;
  int partidasJugadas;
};

// Variables globales
Pregunta preguntas[50];
Usuario usuarios[100];
int totalPreguntas = 0;
int totalUsuarios = 0;
int preguntaActual = 0;
int opcionSeleccionada = 0;
int puntuacionTotal = 0;
int usuarioActual = -1;
bool quizCompletado = false;
bool quizIniciado = false;

// Variables para Encoder por Interrupciones
volatile int encoderPos = 0;
volatile bool encoderChanged = false;
volatile unsigned long lastEncoderInterrupt = 0;
const unsigned long DEBOUNCE_DELAY = 1000;

// Variables para Bot√≥n
volatile bool buttonPressed = false;
volatile unsigned long lastButtonInterrupt = 0;
const unsigned long BUTTON_DEBOUNCE = 200;

// Estados del sistema
enum EstadoSistema {
  ESTADO_INICIO,
  ESTADO_SELECCION_USUARIO,
  ESTADO_JUGANDO,
  ESTADO_FINAL
};

EstadoSistema estadoActual = ESTADO_INICIO;
bool telegramConnected = false;
unsigned long lastTimeBotRan = 0;

// ==================== DECLARACIONES DE FUNCIONES ====================

// Funciones SPIFFS
bool inicializarSPIFFS();
bool cargarPreguntas();
bool guardarUsuarios();
bool cargarUsuarios();
bool guardarPreguntasEnSPIFFS();
void sincronizarArchivo(const char* rutaArchivo, const char* topico);
void reconnect();

// Funciones Telegram
void conectarTelegram();
void procesarComandosTelegram();

// Funciones Usuarios
int buscarUsuario(String nombre);
void agregarUsuario(String nombre);
void ordenarUsuariosPorRanking();

// Funciones Pantalla
void mostrarPantallaInicio();
void mostrarPantallaSeleccionUsuario();
void mostrarPregunta();
void mostrarResultado();
void actualizarPantalla();

// Funciones Quiz
void verificarRespuesta();
void iniciarJuego();
void reiniciarQuiz();

// Funciones Encoder
void IRAM_ATTR encoderISR();
void IRAM_ATTR buttonISR();
void procesarEncoder();
void procesarBoton();

// ==================== INTERRUPCIONES DEL ENCODER ====================

void IRAM_ATTR encoderISR() {
  unsigned long currentTime = micros();
  
  if (currentTime - lastEncoderInterrupt < DEBOUNCE_DELAY) {
    return;
  }
  
  lastEncoderInterrupt = currentTime;
  
  int clkState = digitalRead(ENCODER_CLK);
  int dtState = digitalRead(ENCODER_DT);
  
  if (clkState == dtState) {
    encoderPos++;
  } else {
    encoderPos--;
  }
  
  encoderChanged = true;
}

void IRAM_ATTR buttonISR() {
  unsigned long currentTime = millis();
  
  if (currentTime - lastButtonInterrupt < BUTTON_DEBOUNCE) {
    return;
  }
  
  lastButtonInterrupt = currentTime;
  buttonPressed = true;
}

// ==================== MANEJO DEL ENCODER ====================

void procesarEncoder() {
  if (!encoderChanged) return;
  
  noInterrupts();
  int cambio = encoderPos;
  encoderPos = 0;
  encoderChanged = false;
  interrupts();
  
  if (cambio != 0) {
    switch(estadoActual) {
      case ESTADO_SELECCION_USUARIO:
        if (totalUsuarios > 0) {
          if (cambio > 0) {
            opcionSeleccionada = (opcionSeleccionada + 1) % totalUsuarios;
          } else {
            opcionSeleccionada = (opcionSeleccionada - 1 + totalUsuarios) % totalUsuarios;
          }
        }
        break;
        
      case ESTADO_JUGANDO:
        if (cambio > 0) {
          opcionSeleccionada = (opcionSeleccionada + 1) % 3;
        } else {
          opcionSeleccionada = (opcionSeleccionada - 1 + 3) % 3;
        }
        break;
    }
    
    actualizarPantalla();
    Serial.println("Encoder: " + String(cambio) + " - Opci√≥n: " + String(opcionSeleccionada));
  }
}

void procesarBoton() {
  if (!buttonPressed) return;
  
  noInterrupts();
  buttonPressed = false;
  interrupts();
  
  Serial.println("Bot√≥n presionado");
  
  switch(estadoActual) {
    case ESTADO_INICIO:
      estadoActual = ESTADO_SELECCION_USUARIO;
      opcionSeleccionada = 0;
      break;
    
    case ESTADO_SELECCION_USUARIO:
      if (totalUsuarios > 0) {
        usuarioActual = opcionSeleccionada;
        iniciarJuego();
      }
      break;
    
    case ESTADO_JUGANDO:
      verificarRespuesta();
      break;
    
    case ESTADO_FINAL:
      reiniciarQuiz();
      break;
  }
  
  actualizarPantalla();
}

// ==================== FUNCIONES SPIFFS ====================

bool inicializarSPIFFS() {
  if(!SPIFFS.begin(true)){
    Serial.println("Error al montar SPIFFS");
    return false;
  }
  Serial.println("SPIFFS montado correctamente");
  return true;
}

void sincronizarArchivo(const char* rutaArchivo, const char* topico) {
    // 1. Abrir el archivo para lectura
    File file = SPIFFS.open(rutaArchivo, "r");
    if (!file) {
        Serial.println("Error al abrir el archivo para leerlo.");
        return;
    }

    // 2. Leer todo el contenido del archivo
    String contenidoArchivo = file.readString();
    file.close();

    // 3. Publicar el contenido en el t√≥pico MQTT
    if (client.connected()) {
        client.publish(topico, contenidoArchivo.c_str());
        Serial.print("Archivo ");
        Serial.print(rutaArchivo);
        Serial.print(" sincronizado en el t√≥pico ");
        Serial.println(topico);
    } else {
        Serial.println("Cliente MQTT no conectado. No se pudo sincronizar.");
    }
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Intentando conexi√≥n MQTT...");
    if (client.connect(mqtt_client_id)) {
      Serial.println("¬°Conectado!");
    } else {
      Serial.print("fall√≥, rc=");
      Serial.print(client.state());
      Serial.println(" intentando de nuevo en 5 segundos");
      delay(5000);
    }
  }
}

bool cargarPreguntas() {
  File archivo = SPIFFS.open("/preguntas.json", "r");
  if(!archivo){
    Serial.println("Error al abrir preguntas.json");
    return false;
  }
  
  DynamicJsonDocument doc(4096);
  DeserializationError error = deserializeJson(doc, archivo);
  archivo.close();
  
  if(error){
    Serial.println("Error al parsear JSON: " + String(error.c_str()));
    return false;
  }
  
  JsonArray preguntasArray = doc.as<JsonArray>();
  totalPreguntas = 0;
  
  for(JsonObject preguntaObj : preguntasArray) {
    if(totalPreguntas >= 50) break;
    
    preguntas[totalPreguntas].texto = preguntaObj["texto"].as<String>();
    preguntas[totalPreguntas].opciones[0] = preguntaObj["opciones"][0].as<String>();
    preguntas[totalPreguntas].opciones[1] = preguntaObj["opciones"][1].as<String>();
    preguntas[totalPreguntas].opciones[2] = preguntaObj["opciones"][2].as<String>();
    preguntas[totalPreguntas].respuestaCorrecta = preguntaObj["correcta"].as<int>();
    preguntas[totalPreguntas].puntaje = preguntaObj["puntaje"].as<int>();
    
    totalPreguntas++;
  }
  
  Serial.println("Preguntas cargadas: " + String(totalPreguntas));
  
  // Ordenar usuarios al cargar
  ordenarUsuariosPorRanking();
  return true;
}

bool guardarPreguntasEnSPIFFS() {
  File archivo = SPIFFS.open("/preguntas.json", "w");
  if(!archivo){
    Serial.println("Error al crear preguntas.json");
    return false;
  }
  
  DynamicJsonDocument doc(8192);
  JsonArray preguntasArray = doc.to<JsonArray>();
  
  for(int i = 0; i < totalPreguntas; i++) {
    JsonObject preguntaObj = preguntasArray.createNestedObject();
    preguntaObj["texto"] = preguntas[i].texto;
    
    JsonArray opcionesArray = preguntaObj.createNestedArray("opciones");
    opcionesArray.add(preguntas[i].opciones[0]);
    opcionesArray.add(preguntas[i].opciones[1]);
    opcionesArray.add(preguntas[i].opciones[2]);
    
    preguntaObj["correcta"] = preguntas[i].respuestaCorrecta;
    preguntaObj["puntaje"] = preguntas[i].puntaje;
  }
  
  if(serializeJsonPretty(doc, archivo) == 0){
    Serial.println("Error al escribir en preguntas.json");
    archivo.close();
    return false;
  }
  
  archivo.close();
  sincronizarArchivo("/preguntas.json", "esp32/archivos/preguntas.json");
  Serial.println("Preguntas guardadas correctamente");
  return true;
}

bool guardarUsuarios() {
  File archivo = SPIFFS.open("/usuarios.json", "w");
  if(!archivo){
    Serial.println("Error al crear usuarios.json");
    return false;
  }
  
  DynamicJsonDocument doc(8192);
  JsonArray usuariosArray = doc.to<JsonArray>();
  
  for(int i = 0; i < totalUsuarios; i++) {
    JsonObject usuarioObj = usuariosArray.createNestedObject();
    usuarioObj["nombre"] = usuarios[i].nombre;
    usuarioObj["puntuacionMaxima"] = usuarios[i].puntuacionMaxima;
    usuarioObj["partidasJugadas"] = usuarios[i].partidasJugadas;
  }
  
  if(serializeJsonPretty(doc, archivo) == 0){
    Serial.println("Error al escribir en usuarios.json");
    archivo.close();
    return false;
  }
  
  archivo.close();
  sincronizarArchivo("/usuarios.json", "esp32/archivos/usuarios.json");
  return true;
}

bool cargarUsuarios() {
  if(!SPIFFS.exists("/usuarios.json")) {
    Serial.println("Archivo usuarios.json no existe, se crear√° uno nuevo");
    return guardarUsuarios();
  }
  
  File archivo = SPIFFS.open("/usuarios.json", "r");
  if(!archivo){
    Serial.println("Error al abrir usuarios.json");
    return false;
  }
  
  DynamicJsonDocument doc(8192);
  DeserializationError error = deserializeJson(doc, archivo);
  archivo.close();
  
  if(error){
    Serial.println("Error al parsear JSON: " + String(error.c_str()));
    return false;
  }
  
  JsonArray usuariosArray = doc.as<JsonArray>();
  totalUsuarios = 0;
  
  for(JsonObject usuarioObj : usuariosArray) {
    if(totalUsuarios >= 100) break;
    
    usuarios[totalUsuarios].nombre = usuarioObj["nombre"].as<String>();
    usuarios[totalUsuarios].puntuacionMaxima = usuarioObj["puntuacionMaxima"].as<int>();
    usuarios[totalUsuarios].partidasJugadas = usuarioObj["partidasJugadas"].as<int>();
    
    totalUsuarios++;
  }
  
  Serial.println("Usuarios cargados: " + String(totalUsuarios));
  return true;
}

// ==================== FUNCIONES DE USUARIOS ====================

int buscarUsuario(String nombre) {
  for(int i = 0; i < totalUsuarios; i++) {
    if(usuarios[i].nombre == nombre) {
      return i;
    }
  }
  return -1;
}

void agregarUsuario(String nombre) {
  if(totalUsuarios < 100) {
    usuarios[totalUsuarios].nombre = nombre;
    usuarios[totalUsuarios].puntuacionMaxima = 0;
    usuarios[totalUsuarios].partidasJugadas = 0;
    totalUsuarios++;
    guardarUsuarios();
    Serial.println("Usuario creado: " + nombre);
  }
}

// Funci√≥n para ordenar usuarios por ranking
void ordenarUsuariosPorRanking() {
  for (int i = 0; i < totalUsuarios - 1; i++) {
    for (int j = i + 1; j < totalUsuarios; j++) {
      // Primero por puntuaci√≥n m√°xima (descendente)
      if (usuarios[j].puntuacionMaxima > usuarios[i].puntuacionMaxima) {
        Usuario temp = usuarios[i];
        usuarios[i] = usuarios[j];
        usuarios[j] = temp;
      }
      // Si misma puntuaci√≥n, por partidas jugadas (descendente)
      else if (usuarios[j].puntuacionMaxima == usuarios[i].puntuacionMaxima) {
        if (usuarios[j].partidasJugadas > usuarios[i].partidasJugadas) {
          Usuario temp = usuarios[i];
          usuarios[i] = usuarios[j];
          usuarios[j] = temp;
        }
        // Si mismo n√∫mero de partidas, por orden alfab√©tico
        else if (usuarios[j].partidasJugadas == usuarios[i].partidasJugadas) {
          if (usuarios[j].nombre.compareTo(usuarios[i].nombre) < 0) {
            Usuario temp = usuarios[i];
            usuarios[i] = usuarios[j];
            usuarios[j] = temp;
          }
        }
      }
    }
  }
}

// ==================== FUNCIONES DE MEN√ö TELEGRAM ====================

void mostrarMenuPrincipal(String chat_id) {
  String menuMsg = "ü§ñ *QUIZ ESP32 - MEN√ö PRINCIPAL* ü§ñ\n\n";
  menuMsg += "¬øQu√© quieres hacer?\n\n";
  
  menuMsg += "üë• *GESTI√ìN DE USUARIOS*\n";
  menuMsg += "‚îî‚îÄ‚îÄ /ingresar_usuario - Crear nuevo usuario\n";
  menuMsg += "‚îî‚îÄ‚îÄ /usuarios - Listar todos los usuarios\n";
  menuMsg += "‚îî‚îÄ‚îÄ /estadisticas - Estad√≠sticas detalladas\n\n";
  
  menuMsg += "üèÜ *COMPETICI√ìN*\n";
  menuMsg += "‚îî‚îÄ‚îÄ /ranking - Ver ranking de jugadores\n\n";
  
  menuMsg += "‚ùì *GESTI√ìN DE PREGUNTAS*\n";
  menuMsg += "‚îî‚îÄ‚îÄ /preguntas - Ver todas las preguntas\n";
  menuMsg += "‚îî‚îÄ‚îÄ /agregar_pregunta - Agregar nueva pregunta\n\n";
  
  menuMsg += "üí° *AYUDA*\n";
  menuMsg += "‚îî‚îÄ‚îÄ /help - Mostrar ayuda completa\n";
  menuMsg += "‚îî‚îÄ‚îÄ /menu - Volver a este men√∫\n\n";
  
  menuMsg += "üìç _Usa los comandos desde el teclado o escribe directamente_";
  
  bot.sendMessage(chat_id, menuMsg, "Markdown");
}

void mostrarAyudaGeneral(String chat_id) {
  String helpMsg = "üìö *QUIZ ESP32 - AYUDA Y GU√çA* üìö\n\n";
  
  helpMsg += "üéÆ *SOBRE EL JUEGO*\n";
  helpMsg += "Sistema de quiz multijugador con ESP32, OLED y control por encoder f√≠sico.\n\n";
  
  helpMsg += "‚å®Ô∏è *COMANDOS DISPONIBLES*\n\n";
  
  helpMsg += "üë§ *Gesti√≥n de Usuarios:*\n";
  helpMsg += "‚Ä¢ `/ingresar_usuario NOMBRE` - Crear nuevo usuario\n";
  helpMsg += "   _Ejemplo: `/ingresar_usuario CARLOS`_\n";
  helpMsg += "‚Ä¢ `/usuarios` - Lista completa de usuarios\n";
  helpMsg += "‚Ä¢ `/estadisticas` - Stats detalladas por usuario\n\n";
  
  helpMsg += "üèÖ *Ranking y Puntuaciones:*\n";
  helpMsg += "‚Ä¢ `/ranking` - Ranking ordenado por puntuaci√≥n\n\n";
  
  helpMsg += "‚ùì *Gesti√≥n de Preguntas:*\n";
  helpMsg += "‚Ä¢ `/preguntas` - Ver banco de preguntas completo\n";
  helpMsg += "‚Ä¢ `/agregar_pregunta` - Agregar nueva pregunta\n";
  helpMsg += "   _Formato: Texto|Op1|Op2|Op3|Correcta|Puntos_\n\n";
  
  helpMsg += "üîÑ *Navegaci√≥n:*\n";
  helpMsg += "‚Ä¢ `/start` - Iniciar bot\n";
  helpMsg += "‚Ä¢ `/menu` - Men√∫ principal\n";
  helpMsg += "‚Ä¢ `/help` - Esta ayuda\n\n";
  
  helpMsg += "üéØ *EN EL DISPOSITIVO:*\n";
  helpMsg += "‚Ä¢ üìü _Gira el encoder_ para navegar\n";
  helpMsg += "‚Ä¢ üîò _Presiona el bot√≥n_ para seleccionar\n";
  helpMsg += "‚Ä¢ üí° _LED_ indica respuesta correcta\n\n";
  
  helpMsg += "‚ö†Ô∏è _Los usuarios se crean desde Telegram y se seleccionan en el dispositivo f√≠sico._";
  
  bot.sendMessage(chat_id, helpMsg, "Markdown");
}

void gestionarIngresoUsuario(String chat_id, String text) {
  String nombre = text.substring(String("/ingresar_usuario").length());
  nombre.trim();
  nombre.toUpperCase();
  
  if (nombre.length() == 0) {
    String ayudaUsuario = "üë§ *CREAR USUARIO* üë§\n\n";
    ayudaUsuario += "Para crear un nuevo usuario:\n";
    ayudaUsuario += "`/ingresar_usuario NOMBRE`\n\n";
    ayudaUsuario += "üìù *Ejemplo:*\n";
    ayudaUsuario += "`/ingresar_usuario ANA`\n";
    ayudaUsuario += "`/ingresar_usuario CARLOS`\n\n";
    ayudaUsuario += "‚ö†Ô∏è *Reglas:*\n";
    ayudaUsuario += "‚Ä¢ M√°ximo 10 caracteres\n";
    ayudaUsuario += "‚Ä¢ Solo letras y n√∫meros\n";
    ayudaUsuario += "‚Ä¢ Se convertir√° a may√∫sculas";
    
    bot.sendMessage(chat_id, ayudaUsuario, "Markdown");
    return;
  }
  
  // Validar longitud
  if (nombre.length() > 10) {
    bot.sendMessage(chat_id, "‚ùå El nombre no puede tener m√°s de 10 caracteres", "");
    return;
  }
  
  // Validar caracteres (solo letras, n√∫meros y espacios)
  for (int i = 0; i < nombre.length(); i++) {
    char c = nombre.charAt(i);
    if (!isAlphaNumeric(c) && c != ' ') {
      bot.sendMessage(chat_id, "‚ùå Solo se permiten letras, n√∫meros y espacios", "");
      return;
    }
  }
  
  int usuarioExistente = buscarUsuario(nombre);
  if (usuarioExistente == -1) {
    if (totalUsuarios < 100) {
      agregarUsuario(nombre);
      
      String confirmacion = "‚úÖ *USUARIO CREADO EXITOSAMENTE* ‚úÖ\n\n";
      confirmacion += "üë§ Nombre: " + nombre + "\n";
      confirmacion += "üî¢ ID: " + String(totalUsuarios) + "\n";
      confirmacion += "üéØ Puntuaci√≥n: 0 pts\n";
      confirmacion += "üéÆ Partidas: 0\n\n";
      confirmacion += "üìç _Ahora selecciona este usuario en el dispositivo f√≠sico_";
      
      bot.sendMessage(chat_id, confirmacion, "Markdown");
    } else {
      bot.sendMessage(chat_id, "‚ùå L√≠mite m√°ximo de 100 usuarios alcanzado", "");
    }
  } else {
    bot.sendMessage(chat_id, "‚ö†Ô∏è El usuario *" + nombre + "* ya existe", "Markdown");
  }
}

void listarUsuarios(String chat_id) {
  String usuariosMsg = "üë• *LISTA DE USUARIOS REGISTRADOS* üë•\n\n";
  
  if (totalUsuarios == 0) {
    usuariosMsg += "üì≠ No hay usuarios registrados\n\n";
    usuariosMsg += "üí° Usa `/ingresar_usuario NOMBRE` para crear el primero";
  } else {
    for (int k = 0; k < totalUsuarios; k++) {
      usuariosMsg += "‚Ä¢ " + usuarios[k].nombre + "\n";
    }
    usuariosMsg += "\nüìä Total: *" + String(totalUsuarios) + "* usuarios";
  }
  
  bot.sendMessage(chat_id, usuariosMsg, "Markdown");
}

void mostrarRanking(String chat_id) {
  ordenarUsuariosPorRanking();
  
  String rankingMsg = "üèÜ *RANKING DE JUGADORES* üèÜ\n\n";
  
  if (totalUsuarios == 0) {
    rankingMsg += "üì≠ No hay usuarios registrados\n\n";
    rankingMsg += "üí° Usa `/ingresar_usuario` para crear usuarios";
  } else {
    for (int k = 0; k < totalUsuarios && k < 10; k++) {
      String medalla = "";
      if (k == 0) medalla = "ü•á ";
      else if (k == 1) medalla = "ü•à ";
      else if (k == 2) medalla = "ü•â ";
      else medalla = "üî∏ ";
      
      rankingMsg += medalla + String(k + 1) + ". *" + usuarios[k].nombre + "*\n";
      rankingMsg += "   Puntuaci√≥n: " + String(usuarios[k].puntuacionMaxima) + " pts\n";
      rankingMsg += "   Partidas: " + String(usuarios[k].partidasJugadas) + "\n\n";
    }
    
    if (totalUsuarios > 10) {
      rankingMsg += "üìã ... y *" + String(totalUsuarios - 10) + "* usuarios m√°s\n";
    }
  }
  
  bot.sendMessage(chat_id, rankingMsg, "Markdown");
}

void mostrarEstadisticas(String chat_id) {
  String statsMsg = "üìä *ESTAD√çSTICAS DETALLADAS* üìä\n\n";
  
  if (totalUsuarios == 0) {
    statsMsg += "üì≠ No hay usuarios registrados\n\n";
    statsMsg += "üí° Usa `/ingresar_usuario` para comenzar";
  } else {
    // Estad√≠sticas generales
    int totalPartidas = 0;
    int maximaPuntuacion = 0;
    String mejorJugador = "";
    
    for (int k = 0; k < totalUsuarios; k++) {
      totalPartidas += usuarios[k].partidasJugadas;
      if (usuarios[k].puntuacionMaxima > maximaPuntuacion) {
        maximaPuntuacion = usuarios[k].puntuacionMaxima;
        mejorJugador = usuarios[k].nombre;
      }
    }
    
    statsMsg += "üìà *ESTAD√çSTICAS GENERALES*\n";
    statsMsg += "‚Ä¢ üë• Total usuarios: " + String(totalUsuarios) + "\n";
    statsMsg += "‚Ä¢ üéÆ Total partidas: " + String(totalPartidas) + "\n";
    statsMsg += "‚Ä¢ ‚≠ê Mejor puntuaci√≥n: " + String(maximaPuntuacion) + " pts\n";
    statsMsg += "‚Ä¢ üèÖ Mejor jugador: " + mejorJugador + "\n\n";
    
    statsMsg += "üë§ *ESTAD√çSTICAS POR USUARIO*\n\n";
    
    for (int k = 0; k < totalUsuarios; k++) {
      statsMsg += "üéØ *" + usuarios[k].nombre + "*\n";
      statsMsg += "   Puntuaci√≥n m√°xima: " + String(usuarios[k].puntuacionMaxima) + " pts\n";
      statsMsg += "   Partidas jugadas: " + String(usuarios[k].partidasJugadas) + "\n";
      
      if (usuarios[k].partidasJugadas > 0) {
        float promedio = (float)usuarios[k].puntuacionMaxima / usuarios[k].partidasJugadas;
        statsMsg += "   Promedio: " + String(promedio, 1) + " pts/partida\n";
      }
      statsMsg += "\n";
    }
  }
  
  bot.sendMessage(chat_id, statsMsg, "Markdown");
}

// ==================== FUNCIONES TELEGRAM ====================

void conectarTelegram() {
  Serial.println("Conectando a WiFi...");
  
  WiFi.begin(ssid, password);
  int intentos = 0;
  while (WiFi.status() != WL_CONNECTED && intentos < 20) {
    delay(1000);
    Serial.print(".");
    intentos++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConectado a WiFi!");
    
    // Configurar hora NTP
    configTime(0, 0, "pool.ntp.org");
    time_t now = time(nullptr);
    int timeout = 0;
    while (now < 24 * 3600 && timeout < 30) {
      delay(500);
      now = time(nullptr);
      timeout++;
    }

    secureClient.setCACert(TELEGRAM_CERTIFICATE_ROOT);

    int botUsuarios = bot.getUpdates(0);
    if (botUsuarios != -1) {
      telegramConnected = true;
      Serial.println("Conexi√≥n con Telegram exitosa!");
      bot.sendMessage(CHAT_ID, "ü§ñ Quiz ESP32 conectado! Usa /help para ver comandos", "");
    }
  }
}

void procesarComandosTelegram() {
  if (!telegramConnected) return;

  int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  
  while (numNewMessages) {
    for (int i = 0; i < numNewMessages; i++) {
      String chat_id = bot.messages[i].chat_id;
      String text = bot.messages[i].text;
      text.trim();
      
      // MEN√ö PRINCIPAL Y AYUDA
      if (text == "/start" || text == "/menu") {
        mostrarMenuPrincipal(chat_id);
      }
      else if (text == "/help") {
        mostrarAyudaGeneral(chat_id);
      }
      
      // GESTI√ìN DE USUARIOS
      else if (text.startsWith("/ingresar_usuario")) {
        gestionarIngresoUsuario(chat_id, text);
      }
      else if (text == "/usuarios") {
        listarUsuarios(chat_id);
      }
      else if (text == "/estadisticas") {
        mostrarEstadisticas(chat_id);
      }
      
      // RANKING
      else if (text == "/ranking") {
        mostrarRanking(chat_id);
      }
      
      // PREGUNTAS (mantener tu c√≥digo existente)
      else if (text == "/preguntas") {
        // Tu c√≥digo existente para mostrar preguntas
        String preguntasMsg = "‚ùì *PREGUNTAS DISPONIBLES* ‚ùì\n\n";
        if (totalPreguntas == 0) {
          preguntasMsg += "No hay preguntas cargadas";
        } else {
          for (int k = 0; k < totalPreguntas; k++) {
            preguntasMsg += String(k + 1) + ". " + preguntas[k].texto + "\n";
            preguntasMsg += "   Opciones: " + preguntas[k].opciones[0] + ", " + 
                           preguntas[k].opciones[1] + ", " + preguntas[k].opciones[2] + "\n";
            preguntasMsg += "   Correcta: " + String(preguntas[k].respuestaCorrecta + 1) + 
                           " - Puntos: " + String(preguntas[k].puntaje) + "\n\n";
          }
          preguntasMsg += "Total: " + String(totalPreguntas) + " preguntas";
        }
        bot.sendMessage(chat_id, preguntasMsg, "Markdown");
      }
      else if (text.startsWith("/agregar_pregunta")) {
        // Tu c√≥digo existente para agregar preguntas
        // ... (mantener tu implementaci√≥n actual)
      }
      
      // COMANDO NO RECONOCIDO
      else {
        String errorMsg = "‚ùì *COMANDO NO RECONOCIDO* ‚ùì\n\n";
        errorMsg += "No entend√≠: `" + text + "`\n\n";
        errorMsg += "üí° Usa `/help` para ver todos los comandos disponibles\n";
        errorMsg += "üîß O `/menu` para ver el men√∫ principal";
        
        bot.sendMessage(chat_id, errorMsg, "Markdown");
      }
    }
    numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  }
}

// ==================== FUNCIONES DE PANTALLA ====================

void mostrarPantallaInicio() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("QUIZ MULTIJUGADOR");
  display.setCursor(0, 15);
  display.println("Bienvenidos!!");
  display.println("Click para comenzar");
  display.println("Ver telegram para Comandos");
  display.setCursor(0, 30);
  //display.println("Usuarios: " + String(totalUsuarios));
  display.setCursor(0, 45);
  //display.println("Preguntas: " + String(totalPreguntas));
  display.display();
}

void mostrarPantallaSeleccionUsuario() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("SELECCIONA USUARIO:");

  if (totalUsuarios == 0) {
    display.setCursor(5, 20);
    display.println("No hay usuarios");
    display.setCursor(5, 35);
    display.println("Usa Telegram:");
    display.setCursor(5, 45);
    display.println("/ingresar_usuario");
  } else {
    for (int i = 0; i < totalUsuarios; i++) {
      display.setCursor(5, 15 + i * 12);
      if (i == opcionSeleccionada) {
        display.print("> ");
      } else {
        display.print("  ");
      }
      display.println(usuarios[i].nombre);
    }
  }
  display.display();
}

void mostrarPregunta() {
  display.clearDisplay();
  display.setCursor(0, 0);
  if (usuarioActual >= 0) {
    display.print(usuarios[usuarioActual].nombre);
  }
  display.setCursor(70, 0);
  display.print(preguntaActual + 1);
  display.print("/");
  display.print(totalPreguntas);
  display.setCursor(100, 0);
  display.print(puntuacionTotal);

  // Mostrar pregunta
  String texto = preguntas[preguntaActual].texto;
  int inicio = 0;
  int y = 12;
  
  while (inicio < texto.length()) {
    int fin = inicio + 21;
    if (fin > texto.length()) {
      fin = texto.length();
    }
    display.setCursor(0, y);
    display.println(texto.substring(inicio, fin));
    inicio = fin;
    y += 10;
  }

  // Mostrar opciones
  for (int i = 0; i < 3; i++) {
    display.setCursor(5, 35 + i * 10);
    if (i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    String opcion = preguntas[preguntaActual].opciones[i];
    if (opcion.length() > 18) {
      opcion = opcion.substring(0, 18);
    }
    display.println(opcion);
  }
  display.display();
}

void mostrarResultado() {
  display.clearDisplay();
  display.setCursor(20, 10);
  display.println("QUIZ COMPLETADO!");
  display.setCursor(10, 25);
  if (usuarioActual >= 0) {
    display.print("Jugador: ");
    display.println(usuarios[usuarioActual].nombre);
  }
  display.setCursor(30, 40);
  display.print("Puntos: ");
  display.println(puntuacionTotal);
  display.setCursor(5, 55);
  display.println("Click para reiniciar");
  display.display();
}

void actualizarPantalla() {
  switch(estadoActual) {
    case ESTADO_INICIO:
      mostrarPantallaInicio();
      break;
    case ESTADO_SELECCION_USUARIO:
      mostrarPantallaSeleccionUsuario();
      break;
    case ESTADO_JUGANDO:
      mostrarPregunta();
      break;
    case ESTADO_FINAL:
      mostrarResultado();
      break;
  }
}

// ==================== FUNCIONES DEL QUIZ ====================

void verificarRespuesta() {
  bool correcta = (opcionSeleccionada == preguntas[preguntaActual].respuestaCorrecta);

  if (correcta) {
    puntuacionTotal += preguntas[preguntaActual].puntaje;
    digitalWrite(LED_PIN, HIGH);
    delay(500);
    digitalWrite(LED_PIN, LOW);
  }

  preguntaActual++;
  if (preguntaActual >= totalPreguntas) {
    quizCompletado = true;
    if (usuarioActual >= 0) {
      usuarios[usuarioActual].partidasJugadas++;
      if (puntuacionTotal > usuarios[usuarioActual].puntuacionMaxima) {
        usuarios[usuarioActual].puntuacionMaxima = puntuacionTotal;
      }
      guardarUsuarios();
      ordenarUsuariosPorRanking();
    }
    estadoActual = ESTADO_FINAL;
    mostrarResultado();
  } else {
    opcionSeleccionada = 0;
    mostrarPregunta();
  }
}

void iniciarJuego() {
  quizIniciado = true;
  quizCompletado = false;
  preguntaActual = 0;
  opcionSeleccionada = 0;
  puntuacionTotal = 0;
  estadoActual = ESTADO_JUGANDO;
  mostrarPregunta();
  Serial.println("Juego iniciado");
}

void reiniciarQuiz() {
  preguntaActual = 0;
  opcionSeleccionada = 0;
  puntuacionTotal = 0;
  quizCompletado = false;
  quizIniciado = false;
  estadoActual = ESTADO_INICIO;
  mostrarPantallaInicio();
}

// ==================== SETUP Y LOOP ====================

void setup() {
  Serial.begin(9600);
  Serial.println("Iniciando Quiz ESP32...");
  
  pinMode(LED_PIN, OUTPUT);
  pinMode(ENCODER_CLK, INPUT_PULLUP);
  pinMode(ENCODER_DT, INPUT_PULLUP);
  pinMode(ENCODER_SW, INPUT_PULLUP);
  
  // Configurar interrupciones
  attachInterrupt(digitalPinToInterrupt(ENCODER_CLK), encoderISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENCODER_DT), encoderISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENCODER_SW), buttonISR, FALLING);
  
  // Inicializar display
  if(!display.begin(0x3c, true)) {
    Serial.println("Error inicializando OLED");
    while(1);
  }
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  display.clearDisplay();
  
  // Inicializar sistema
  inicializarSPIFFS();
  cargarPreguntas();
  cargarUsuarios();
  conectarTelegram();
  client.setServer(mqtt_server, mqtt_port);
  mostrarPantallaInicio();
  Serial.println("Sistema listo");
}

void loop() {
  // Procesar Telegram cada 200ms
  if (millis() > lastTimeBotRan + 200) {
    procesarComandosTelegram();
    lastTimeBotRan = millis();
  }
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // Procesar encoder y bot√≥n (prioridad m√°xima)
  procesarEncoder();
  procesarBoton();

  delay(10); // Peque√±o delay para estabilidad
}