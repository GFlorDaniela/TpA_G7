#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>

// OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SH1106G display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// Pines
#define LED_PIN 23
#define ENCODER_CLK 18
#define ENCODER_DT 5
#define ENCODER_SW 19

// Estructuras de datos
struct Pregunta {
  String texto;
  String opciones[3];
  int respuestaCorrecta;
  int puntaje;
};

struct Usuario {
  String nombre;
  int puntuacionMaxima;
  int partidasJugadas;
};

// SIMULACIÓN DE ARCHIVOS - Contenido de preguntas.txt
const char* ARCHIVO_PREGUNTAS[] = {
  "¿Qué lenguaje usa Arduino?;C++;Python;Java;0",
  "Capital de Francia;Roma;Madrid;París;2", 
  "Color bandera Argentina;Azul;Blanco;Celeste;2",
  "¿2+2?;3;4;5;1",
  "Animal Australia;Canguro;Koala;Emú;0"
};

// SIMULACIÓN DE ARCHIVOS - Contenido de puntajes.txt
const int ARCHIVO_PUNTAJES[] = {10, 15, 10, 5, 10};

// Variables globales
Pregunta preguntas[10];
Usuario usuarios[20];
int totalPreguntas = 5;
int totalUsuarios = 0;
int preguntaActual = 0;
int opcionSeleccionada = 0;
int puntuacionTotal = 0;
int usuarioActual = -1;
bool quizCompletado = false;
bool quizIniciado = false;
bool ingresandoNombre = false;
String nombreTemp = "";

// NUEVAS VARIABLES PARA SELECCIÓN DE MODO
bool seleccionandoModo = false;
String modoPartida = "ranking"; // "1vs1", "ranking", "multijugador"
String oponenteSeleccionado = "";

// Variables encoder
int lastCLK = HIGH;
unsigned long lastButtonPress = 0;

// FUNCIONES DE SIMULACIÓN DE ARCHIVOS
void simularCargaArchivos() {
  Serial.println("=== SIMULANDO SISTEMA DE ARCHIVOS ===");
  Serial.println("Cargando preguntas desde 'preguntas.txt'...");
  Serial.println("Cargando puntajes desde 'puntajes.txt'...");
  
  for(int i = 0; i < totalPreguntas; i++){
    String linea = ARCHIVO_PREGUNTAS[i];
    
    int separadores[5];
    int sepIndex = 0;
    
    for(int j = 0; j < linea.length() && sepIndex < 5; j++){
      if(linea.charAt(j) == ';'){
        separadores[sepIndex++] = j;
      }
    }
    
    if(sepIndex == 4){
      preguntas[i].texto = linea.substring(0, separadores[0]);
      preguntas[i].opciones[0] = linea.substring(separadores[0] + 1, separadores[1]);
      preguntas[i].opciones[1] = linea.substring(separadores[1] + 1, separadores[2]);
      preguntas[i].opciones[2] = linea.substring(separadores[2] + 1, separadores[3]);
      preguntas[i].respuestaCorrecta = linea.substring(separadores[3] + 1).toInt();
      preguntas[i].puntaje = ARCHIVO_PUNTAJES[i];
      
      Serial.println("Cargada: " + preguntas[i].texto);
    }
  }
  Serial.println("Total: " + String(totalPreguntas) + " preguntas cargadas\n");
}

// NUEVA FUNCIÓN: Mostrar menú de selección de modo
void mostrarMenu() {
  display.clearDisplay();
  display.setCursor(10, 5);
  display.println("SELECCIONA MODO");
  
  String opciones[3] = {"1 vs 1", "Contra el mejor", "Multijugador"};

  for (int i = 0; i < 3; i++) {
    display.setCursor(5, 20 + i * 12);
    if (i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.println(opciones[i]);
  }

  // Mostrar descripción del modo seleccionado
  display.setCursor(0, 50);
  switch(opcionSeleccionada) {
    case 0: display.println("Elige un rival directo"); break;
    case 1: display.println("Supera el mejor puntaje"); break;
    case 2: display.println("Competis con todos"); break;
  }

  display.display();
}

// NUEVA FUNCIÓN: Mostrar selección de oponente para 1vs1
void mostrarSeleccionOponente() {
  display.clearDisplay();
  display.setCursor(10, 5);
  display.println("SELECCIONA RIVAL");
  
  for(int i = 0; i < totalUsuarios; i++) {
    display.setCursor(5, 18 + i * 10);
    if(i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    
    String info = usuarios[i].nombre + " (" + usuarios[i].puntuacionMaxima + " pts)";
    if(info.length() > 18) {
      info = info.substring(0, 18);
    }
    display.println(info);
  }
  
  display.setCursor(0, 55);
  display.println("Click: seleccionar");
  display.display();
}

// NUEVA FUNCIÓN: Procesar selección de modo
void procesarSeleccionModo() {
  int currentCLK = digitalRead(ENCODER_CLK);
  
  if(currentCLK != lastCLK && currentCLK == LOW) {
    if(digitalRead(ENCODER_DT) == LOW) {
      opcionSeleccionada++;
    } else {
      opcionSeleccionada--;
    }
    
    if(opcionSeleccionada < 0) opcionSeleccionada = 2;
    if(opcionSeleccionada > 2) opcionSeleccionada = 0;
    
    mostrarMenu();
  }
  lastCLK = currentCLK;
  
  if(digitalRead(ENCODER_SW) == LOW && millis() - lastButtonPress > 300) {
    lastButtonPress = millis();
    
    switch(opcionSeleccionada) {
      case 0: 
        modoPartida = "1vs1";
        // Pasar a selección de oponente
        opcionSeleccionada = 0;
        break;
      case 1: 
        modoPartida = "ranking"; 
        seleccionandoModo = false;
        ingresandoNombre = true;
        nombreTemp = "A";
        mostrarIngresoNombre();
        break;
      case 2: 
        modoPartida = "multijugador";
        seleccionandoModo = false;
        ingresandoNombre = true;
        nombreTemp = "A";
        mostrarIngresoNombre();
        break;
    }
    Serial.println("Modo seleccionado: " + modoPartida);
  }
}

// NUEVA FUNCIÓN: Procesar selección de oponente
void procesarSeleccionOponente() {
  int currentCLK = digitalRead(ENCODER_CLK);
  
  if(currentCLK != lastCLK && currentCLK == LOW) {
    if(digitalRead(ENCODER_DT) == LOW) {
      opcionSeleccionada++;
    } else {
      opcionSeleccionada--;
    }
    
    if(opcionSeleccionada < 0) opcionSeleccionada = totalUsuarios - 1;
    if(opcionSeleccionada >= totalUsuarios) opcionSeleccionada = 0;
    
    mostrarSeleccionOponente();
  }
  lastCLK = currentCLK;
  
  if(digitalRead(ENCODER_SW) == LOW && millis() - lastButtonPress > 300) {
    lastButtonPress = millis();
    
    oponenteSeleccionado = usuarios[opcionSeleccionada].nombre;
    seleccionandoModo = false;
    ingresandoNombre = true;
    nombreTemp = "A";
    mostrarIngresoNombre();
    
    Serial.println("Rival seleccionado: " + oponenteSeleccionado);
  }
}

// FUNCIONES DE USUARIOS (para Wokwi)
void inicializarUsuariosEjemplo() {
  // Agregar algunos usuarios de ejemplo
  usuarios[0] = {"ANA", 45, 3};
  usuarios[1] = {"CARLOS", 35, 2};
  usuarios[2] = {"MARIA", 50, 4};
  totalUsuarios = 3;
  
  Serial.println("Usuarios de ejemplo cargados:");
  for(int i = 0; i < totalUsuarios; i++) {
    Serial.println(usuarios[i].nombre + " - Max: " + usuarios[i].puntuacionMaxima + 
                  " - Partidas: " + usuarios[i].partidasJugadas);
  }
}

int buscarUsuario(String nombre) {
  for(int i = 0; i < totalUsuarios; i++) {
    if(usuarios[i].nombre == nombre) {
      return i;
    }
  }
  return -1;
}

void agregarUsuario(String nombre) {
  if(totalUsuarios < 20) {
    usuarios[totalUsuarios].nombre = nombre;
    usuarios[totalUsuarios].puntuacionMaxima = 0;
    usuarios[totalUsuarios].partidasJugadas = 0;
    usuarioActual = totalUsuarios;
    totalUsuarios++;
    Serial.println("Nuevo usuario creado: " + nombre);
  }
}

void actualizarPuntuacionUsuario() {
  if(usuarioActual >= 0) {
    usuarios[usuarioActual].partidasJugadas++;
    if(puntuacionTotal > usuarios[usuarioActual].puntuacionMaxima) {
      usuarios[usuarioActual].puntuacionMaxima = puntuacionTotal;
    }
    Serial.println("Usuario " + usuarios[usuarioActual].nombre + 
                  " actualizado. Max: " + usuarios[usuarioActual].puntuacionMaxima +
                  " Partidas: " + usuarios[usuarioActual].partidasJugadas);
  }
}

void mostrarRanking() {
  Serial.println("=== RANKING ACTUAL ===");
  
  Usuario rankingTemp[totalUsuarios];
  for(int i = 0; i < totalUsuarios; i++) {
    rankingTemp[i] = usuarios[i];
  }
  
  // ORDENAR MEJORADO
  for(int i = 0; i < totalUsuarios - 1; i++) {
    for(int j = i + 1; j < totalUsuarios; j++) {
      bool debeIntercambiar = false;
      
      // Criterio 1: Puntuación máxima
      if(rankingTemp[j].puntuacionMaxima > rankingTemp[i].puntuacionMaxima) {
        debeIntercambiar = true;
      }
      // Criterio 2: Si misma puntuación, más partidas
      else if(rankingTemp[j].puntuacionMaxima == rankingTemp[i].puntuacionMaxima) {
        if(rankingTemp[j].partidasJugadas > rankingTemp[i].partidasJugadas) {
          debeIntercambiar = true;
        }
        // Criterio 3: Si mismo todo, orden alfabético
        else if(rankingTemp[j].partidasJugadas == rankingTemp[i].partidasJugadas) {
          if(rankingTemp[j].nombre < rankingTemp[i].nombre) {
            debeIntercambiar = true;
          }
        }
      }
      
      if(debeIntercambiar) {
        Usuario temp = rankingTemp[i];
        rankingTemp[i] = rankingTemp[j];
        rankingTemp[j] = temp;
      }
    }
  }
  
  // MOSTRAR
  for(int i = 0; i < totalUsuarios; i++) {
    String posicion = String(i+1) + ".";
    if(i < 9) posicion = " " + posicion;
    
    Serial.println(posicion + " " + rankingTemp[i].nombre + 
                  " - Puntos: " + rankingTemp[i].puntuacionMaxima +
                  " - Partidas: " + rankingTemp[i].partidasJugadas);
  }
  Serial.println("=====================");
}

// FUNCIONES DE INTERFAZ
void mostrarPantallaInicio() {
  display.clearDisplay();
  display.setCursor(10, 10);
  display.println("QUIZ ESP32");
  display.setCursor(5, 25);
  display.println("Wokwi Edition");
  display.setCursor(0, 45);
  display.println("Gira encoder empezar");
  display.display();
}

void mostrarIngresoNombre() {
  display.clearDisplay();
  display.setCursor(10, 10);
  display.println("INGRESA TU NOMBRE");
  display.setCursor(0, 25);
  display.print("Nombre: ");
  display.println(nombreTemp);
  display.setCursor(0, 35);
  display.print("Letra actual: ");
  display.print(char(nombreTemp.length() > 0 ? nombreTemp.charAt(nombreTemp.length()-1) : 'A'));
  display.setCursor(0, 45);
  display.print("Click: nueva letra");
  display.setCursor(0, 55);
  display.print("Mantén>1s: FINALIZAR");
  display.display();
}

void mostrarTextoEnLineas(String texto, int x, int y, int anchoMax) {
  int inicio = 0;
  int fin = anchoMax / 6;
  
  while (inicio < texto.length()) {
    if (fin > texto.length()) fin = texto.length();
    
    int ultimoEspacio = texto.lastIndexOf(' ', fin);
    if (ultimoEspacio == -1 || ultimoEspacio <= inicio) ultimoEspacio = fin;
    
    display.setCursor(x, y);
    display.println(texto.substring(inicio, ultimoEspacio));
    
    y += 10;
    inicio = ultimoEspacio + 1;
    fin = inicio + (anchoMax / 6);
  }
}

String limpiarTexto(String texto) {
  texto.replace("á", "a");
  texto.replace("é", "e");
  texto.replace("í", "i");
  texto.replace("ó", "o");
  texto.replace("ú", "u");
  texto.replace("ñ", "n");
  texto.replace("¿", "?");
  texto.replace("¡", "!");
  return texto;
}

// FUNCIÓN MODIFICADA: Mostrar pregunta con info del modo
void mostrarPregunta() {
  display.clearDisplay();
  
  // Header con modo, usuario, progreso y puntuación
  display.setCursor(0, 0);
  
  // Mostrar indicador del modo
  if(modoPartida == "1vs1") display.print("[1v1] ");
  else if(modoPartida == "ranking") display.print("[R] ");
  else display.print("[M] ");
  
  if(usuarioActual >= 0) {
    display.print(usuarios[usuarioActual].nombre);
  } else {
    display.print("JUGADOR");
  }
  
  // En modo 1vs1 mostrar vs oponente
  if(modoPartida == "1vs1" && oponenteSeleccionado != "") {
    display.setCursor(70, 0);
    display.print("vs ");
    display.print(oponenteSeleccionado);
  }
  
  display.setCursor(0, 10);
  display.print(preguntaActual + 1);
  display.print("/");
  display.print(totalPreguntas);
  display.setCursor(70, 10);
  display.print("Pts: ");
  display.print(puntuacionTotal);
  
  // Pregunta
  mostrarTextoEnLineas(limpiarTexto(preguntas[preguntaActual].texto), 0, 22, 128);
  
  // Opciones con selector
  for(int i = 0; i < 3; i++) {
    display.setCursor(5, 35 + i * 12);
    if(i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.println(preguntas[preguntaActual].opciones[i]);
  }
  
  display.display();
}

// FUNCIÓN MODIFICADA: Mostrar resultado con info del modo
void mostrarResultado() {
  display.clearDisplay();
  display.setCursor(20, 5);
  display.println("QUIZ COMPLETADO!");
  
  display.setCursor(10, 18);
  if(usuarioActual >= 0) {
    display.print("Jugador: ");
    display.println(usuarios[usuarioActual].nombre);
  }
  
  // Mostrar info específica del modo
  if(modoPartida == "1vs1" && oponenteSeleccionado != "") {
    int indiceOponente = buscarUsuario(oponenteSeleccionado);
    if(indiceOponente != -1) {
      display.setCursor(10, 30);
      display.print("VS: ");
      display.println(oponenteSeleccionado);
      display.setCursor(10, 42);
      display.print("Puntos: ");
      display.print(puntuacionTotal);
      display.print("/");
      display.print(usuarios[indiceOponente].puntuacionMaxima);
    }
  } else if(modoPartida == "ranking") {
    // Buscar el mejor puntaje
    int mejorPuntaje = 0;
    for(int i = 0; i < totalUsuarios; i++) {
      if(usuarios[i].puntuacionMaxima > mejorPuntaje) {
        mejorPuntaje = usuarios[i].puntuacionMaxima;
      }
    }
    display.setCursor(10, 30);
    display.print("Record: ");
    display.println(mejorPuntaje);
    display.setCursor(10, 42);
    display.print("Tus pts: ");
    display.println(puntuacionTotal);
  } else {
    // Multijugador - mostrar puntuación normal
    display.setCursor(30, 30);
    display.print("Puntos: ");
    display.println(puntuacionTotal);
  }
  
  display.setCursor(5, 55);
  display.println("Click para reiniciar");
  display.display();
}

void verificarRespuesta() {
  bool correcta = (opcionSeleccionada == preguntas[preguntaActual].respuestaCorrecta);
  
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println(preguntas[preguntaActual].texto);
  display.setCursor(0, 15);
  display.print("Elegiste: ");
  display.println(preguntas[preguntaActual].opciones[opcionSeleccionada]);
  
  if(correcta) {
    puntuacionTotal += preguntas[preguntaActual].puntaje;
    display.setCursor(0, 30);
    display.print("CORRECTO! +");
    display.print(preguntas[preguntaActual].puntaje);
    digitalWrite(LED_PIN, HIGH);
  } else {
    display.setCursor(0, 30);
    display.println("INCORRECTO");
    display.setCursor(0, 45);
    display.print("Correcta: ");
    display.println(preguntas[preguntaActual].opciones[preguntas[preguntaActual].respuestaCorrecta]);
  }
  
  display.display();
  delay(3000);
  digitalWrite(LED_PIN, LOW);
  
  preguntaActual++;
  if(preguntaActual >= totalPreguntas) {
    quizCompletado = true;
    actualizarPuntuacionUsuario();
    mostrarRanking();
    mostrarResultado();
  } else {
    opcionSeleccionada = 0;
    mostrarPregunta();
  }
}

// FUNCIÓN MODIFICADA: Reiniciar quiz con nuevas variables
void reiniciarQuiz() {
  preguntaActual = 0;
  opcionSeleccionada = 0;
  puntuacionTotal = 0;
  quizCompletado = false;
  quizIniciado = false;
  seleccionandoModo = false;
  ingresandoNombre = false;
  nombreTemp = "";
  usuarioActual = -1;
  oponenteSeleccionado = "";
  modoPartida = "ranking";
  mostrarPantallaInicio();
}

void procesarEntradaNombre() {
  static char letraActual = 'A';
  static unsigned long ultimoGiro = 0;
  static unsigned long inicioPresion = 0;
  static bool botonPresionado = false;
  
  int currentCLK = digitalRead(ENCODER_CLK);
  
  // Manejo del encoder para cambiar letras
  if(currentCLK != lastCLK && currentCLK == LOW) {
    if(millis() - ultimoGiro > 150) {
      if(digitalRead(ENCODER_DT) == LOW) {
        letraActual++;
      } else {
        letraActual--;
      }
      
      if(letraActual < 'A') letraActual = 'Z';
      if(letraActual > 'Z') letraActual = 'A';
      
      if(nombreTemp.length() > 0) {
        nombreTemp.remove(nombreTemp.length() - 1);
      }
      nombreTemp += String(letraActual);
      
      mostrarIngresoNombre();
      ultimoGiro = millis();
    }
  }
  lastCLK = currentCLK;
  
  // Manejo del botón
  if(digitalRead(ENCODER_SW) == LOW) {
    if(!botonPresionado) {
      botonPresionado = true;
      inicioPresion = millis();
    }
    
    if(botonPresionado && (millis() - inicioPresion > 1000)) {
      if(nombreTemp.length() > 0) {
        int usuarioExistente = buscarUsuario(nombreTemp);
        if(usuarioExistente == -1) {
          agregarUsuario(nombreTemp);
        } else {
          usuarioActual = usuarioExistente;
          Serial.println("Usuario existente: " + nombreTemp);
        }
        
        ingresandoNombre = false;
        quizIniciado = true;
        botonPresionado = false;
        mostrarPregunta();
      }
    }
  } else {
    if(botonPresionado) {
      if(millis() - inicioPresion <= 1000) {
        if(nombreTemp.length() == 0) {
          nombreTemp = "A";
          letraActual = 'A';
          mostrarIngresoNombre();
        } else if(nombreTemp.length() < 8) {
          nombreTemp += "A";
          letraActual = 'A';
          mostrarIngresoNombre();
        }
      }
      botonPresionado = false;
    }
  }
}

void setup() {
  Serial.begin(115200);
  
  pinMode(LED_PIN, OUTPUT);
  pinMode(ENCODER_CLK, INPUT_PULLUP);
  pinMode(ENCODER_DT, INPUT_PULLUP);
  pinMode(ENCODER_SW, INPUT_PULLUP);
  
  display.begin(0x3c, true);
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  display.clearDisplay();
  
  simularCargaArchivos();
  inicializarUsuariosEjemplo();
  
  mostrarPantallaInicio();
  Serial.println("Quiz listo - Gira encoder para comenzar");
}

void loop() {
  int currentCLK = digitalRead(ENCODER_CLK);
  
  if(seleccionandoModo) {
    if(modoPartida == "1vs1" && oponenteSeleccionado == "") {
      procesarSeleccionOponente();
    } else {
      procesarSeleccionModo();
    }
    return;
  }
  
  if(ingresandoNombre) {
    procesarEntradaNombre();
    return;
  }
  
  if(quizCompletado) {
    if(digitalRead(ENCODER_SW) == LOW && millis() - lastButtonPress > 500) {
      lastButtonPress = millis();
      reiniciarQuiz();
    }
    return;
  }
  
  if(!quizIniciado) {
    if(currentCLK != lastCLK) {
      seleccionandoModo = true;
      opcionSeleccionada = 0;
      mostrarMenu();
    }
    lastCLK = currentCLK;
    return;
  }
  
  // Navegación normal del quiz
  if(currentCLK != lastCLK && currentCLK == LOW) {
    if(digitalRead(ENCODER_DT) == LOW) {
      opcionSeleccionada++;
    } else {
      opcionSeleccionada--;
    }
    
    if(opcionSeleccionada < 0) opcionSeleccionada = 2;
    if(opcionSeleccionada > 2) opcionSeleccionada = 0;
    
    mostrarPregunta();
  }
  lastCLK = currentCLK;
  
  if(digitalRead(ENCODER_SW) == LOW && millis() - lastButtonPress > 300) {
    lastButtonPress = millis();
    verificarRespuesta();
  }
}