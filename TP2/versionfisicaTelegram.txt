#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <SPIFFS.h>
#include <ArduinoJson.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <HTTPClient.h>

// OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SH1106G display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// Pines
#define LED_PIN 23
#define ENCODER_CLK 18
#define ENCODER_DT 5
#define ENCODER_SW 19

// WiFi y Telegram - CONFIGURA ESTOS DATOS
const char *ssid = "TU_WIFI_SSID";
const char *password = "TU_WIFI_PASSWORD";

// Telegram - CONFIGURA CON TUS DATOS
const String BOT_TOKEN = "TU_BOT_TOKEN";
const String CHAT_ID = "TU_CHAT_ID";

// Clients
WiFiClientSecure secureClient;
UniversalTelegramBot bot(BOT_TOKEN, secureClient);

// Estructuras de datos
struct Pregunta {
  String texto;
  String opciones[3];
  int respuestaCorrecta;
  int puntaje;
};

struct Usuario {
  String nombre;
  int puntuacionMaxima;
  int partidasJugadas;
  time_t ultimaPartida;
};

// Variables globales
Pregunta preguntas[50];
Usuario usuarios[100];
int totalPreguntas = 0;
int totalUsuarios = 0;
int preguntaActual = 0;
int opcionSeleccionada = 0;
int puntuacionTotal = 0;
int usuarioActual = -1;
int oponenteActual = -1;
bool quizCompletado = false;
bool quizIniciado = false;
String modoPartida = "";

// Variables encoder para ESP32 real
unsigned long lastButtonPress = 0;
const unsigned long BUTTON_DEBOUNCE_MS = 50;
const unsigned long ENCODER_STEP_MS = 50;
int lastCLK = HIGH;
bool encoderEnabled = true;
unsigned long lastEncoderTime = 0;

// Variables de sincronizaci√≥n Telegram
bool necesitaActualizarPantalla = false;
unsigned long ultimaActualizacionPantalla = 0;
const unsigned long INTERVALO_ACTUALIZACION = 100;

// Estados del sistema
enum EstadoSistema {
  ESTADO_INICIO,
  ESTADO_SELECCION_MODO,
  ESTADO_SELECCION_USUARIO,
  ESTADO_ESPERA_INICIO,
  ESTADO_SELECCION_OPONENTE,
  ESTADO_JUGANDO,
  ESTADO_FINAL
};

EstadoSistema estadoActual = ESTADO_INICIO;
bool telegramConnected = false;
unsigned long lastTimeBotRan = 0;

// ==================== FUNCIONES ENCODER OPTIMIZADAS ====================

int readEncoderWokwi() {
  static int lastCLK = HIGH;
  int currentCLK = digitalRead(ENCODER_CLK);
  int currentDT = digitalRead(ENCODER_DT);
  
  // Detectar flanco de bajada en CLK
  if (lastCLK == HIGH && currentCLK == LOW) {
    lastCLK = currentCLK;
    
    // Leer estado de DT para determinar direcci√≥n
    if (currentDT == HIGH) {
      return 1;  // Giro horario
    } else {
      return -1; // Giro antihorario
    }
  }
  
  lastCLK = currentCLK;
  return 0;
}

bool buttonPressedWokwi() {
  static unsigned long lastPress = 0;
  static bool lastState = HIGH;
  
  int currentState = digitalRead(ENCODER_SW);
  
  // Detectar flanco de bajada con debounce simple
  if (lastState == HIGH && currentState == LOW) {
    if (millis() - lastPress > BUTTON_DEBOUNCE_MS) {
      lastPress = millis();
      lastState = currentState;
      return true;
    }
  }
  
  lastState = currentState;
  return false;
}

void handleEncoderWokwi() {
  static int lastCLK = HIGH;
  static unsigned long lastEncoderAction = 0;
  int currentCLK = digitalRead(ENCODER_CLK);
  
  // Solo procesar si ha pasado el tiempo de debounce
  if (millis() - lastEncoderAction < ENCODER_STEP_MS) {
    return;
  }
  
  // Detectar cambio en CLK
  if (lastCLK != currentCLK) {
    lastEncoderAction = millis();
    
    // Si CLK cambi√≥, leer DT para determinar direcci√≥n
    if (currentCLK == LOW) {
      int currentDT = digitalRead(ENCODER_DT);
      if (currentDT == HIGH) {
        // Giro hacia la derecha
        if (opcionSeleccionada < 2) opcionSeleccionada++;
        else opcionSeleccionada = 0;
      } else {
        // Giro hacia la izquierda  
        if (opcionSeleccionada > 0) opcionSeleccionada--;
        else opcionSeleccionada = 2;
      }
      
      // Actualizar pantalla seg√∫n el estado actual
      actualizarPantallaSegunEstado();
    }
    
    lastCLK = currentCLK;
  }
}

// ==================== FUNCIONES SPIFFS ====================

bool inicializarSPIFFS() {
  if(!SPIFFS.begin(true)){
    Serial.println("Error al montar SPIFFS");
    return false;
  }
  Serial.println("SPIFFS montado correctamente");
  return true;
}

bool cargarPreguntas() {
  File archivo = SPIFFS.open("/preguntas.json", "r");
  if(!archivo){
    Serial.println("Error al abrir preguntas.json");
    return false;
  }
  
  DynamicJsonDocument doc(4096);
  DeserializationError error = deserializeJson(doc, archivo);
  archivo.close();
  
  if(error){
    Serial.println("Error al parsear JSON: " + String(error.c_str()));
    return false;
  }
  
  JsonArray preguntasArray = doc.as<JsonArray>();
  totalPreguntas = 0;
  
  for(JsonObject preguntaObj : preguntasArray) {
    if(totalPreguntas >= 50) break;
    
    preguntas[totalPreguntas].texto = preguntaObj["texto"].as<String>();
    preguntas[totalPreguntas].opciones[0] = preguntaObj["opciones"][0].as<String>();
    preguntas[totalPreguntas].opciones[1] = preguntaObj["opciones"][1].as<String>();
    preguntas[totalPreguntas].opciones[2] = preguntaObj["opciones"][2].as<String>();
    preguntas[totalPreguntas].respuestaCorrecta = preguntaObj["correcta"].as<int>();
    preguntas[totalPreguntas].puntaje = preguntaObj["puntaje"].as<int>();
    
    totalPreguntas++;
  }
  
  Serial.println("Preguntas cargadas: " + String(totalPreguntas));
  return true;
}

bool guardarUsuarios() {
  File archivo = SPIFFS.open("/usuarios.json", "w");
  if(!archivo){
    Serial.println("Error al crear usuarios.json");
    return false;
  }
  
  DynamicJsonDocument doc(8192);
  JsonArray usuariosArray = doc.to<JsonArray>();
  
  for(int i = 0; i < totalUsuarios; i++) {
    JsonObject usuarioObj = usuariosArray.createNestedObject();
    usuarioObj["nombre"] = usuarios[i].nombre;
    usuarioObj["puntuacionMaxima"] = usuarios[i].puntuacionMaxima;
    usuarioObj["partidasJugadas"] = usuarios[i].partidasJugadas;
    usuarioObj["ultimaPartida"] = usuarios[i].ultimaPartida;
  }
  
  if(serializeJsonPretty(doc, archivo) == 0){
    Serial.println("Error al escribir en usuarios.json");
    archivo.close();
    return false;
  }
  
  archivo.close();
  Serial.println("Usuarios guardados correctamente");
  return true;
}

bool cargarUsuarios() {
  if(!SPIFFS.exists("/usuarios.json")) {
    Serial.println("Archivo usuarios.json no existe, se crear√° uno nuevo");
    return guardarUsuarios(); // Crear archivo vac√≠o
  }
  
  File archivo = SPIFFS.open("/usuarios.json", "r");
  if(!archivo){
    Serial.println("Error al abrir usuarios.json");
    return false;
  }
  
  DynamicJsonDocument doc(8192);
  DeserializationError error = deserializeJson(doc, archivo);
  archivo.close();
  
  if(error){
    Serial.println("Error al parsear JSON: " + String(error.c_str()));
    return false;
  }
  
  JsonArray usuariosArray = doc.as<JsonArray>();
  totalUsuarios = 0;
  
  for(JsonObject usuarioObj : usuariosArray) {
    if(totalUsuarios >= 100) break;
    
    usuarios[totalUsuarios].nombre = usuarioObj["nombre"].as<String>();
    usuarios[totalUsuarios].puntuacionMaxima = usuarioObj["puntuacionMaxima"].as<int>();
    usuarios[totalUsuarios].partidasJugadas = usuarioObj["partidasJugadas"].as<int>();
    usuarios[totalUsuarios].ultimaPartida = usuarioObj["ultimaPartida"].as<time_t>();
    
    totalUsuarios++;
  }
  
  Serial.println("Usuarios cargados: " + String(totalUsuarios));
  return true;
}

// ==================== FUNCIONES TELEGRAM ====================

void conectarTelegram() {
  Serial.println("üì∂ Conectando a WiFi...");
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Conectando WiFi...");
  display.display();

  WiFi.begin(ssid, password);

  int intentos = 0;
  while (WiFi.status() != WL_CONNECTED && intentos < 20) {
    delay(1000);
    Serial.print(".");
    intentos++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ Conectado a WiFi!");
    Serial.print("üì° IP: ");
    Serial.println(WiFi.localIP());

    // Para ESP32 real: usar certificados seguros
    secureClient.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Agrega el certificado

    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Conectando Telegram...");
    display.display();

    int botUsuarios = bot.getUpdates(0);
    if (botUsuarios != -1) {
      telegramConnected = true;
      Serial.println("‚úÖ Conexi√≥n con Telegram exitosa!");

      bot.sendMessage(CHAT_ID, "ü§ñ ¬°Bot del Quiz ESP32 conectado! üéÆ", "");
      bot.sendMessage(CHAT_ID, "Usa /seleccionar_partida para elegir modo de juego", "");

      estadoActual = ESTADO_INICIO;
      mostrarPantallaConexiones();
    } else {
      Serial.println("‚ùå Error en conexi√≥n Telegram");
      estadoActual = ESTADO_INICIO;
      mostrarPantallaConexiones();
    }
  } else {
    Serial.println("\n‚ùå Error conectando a WiFi");
    estadoActual = ESTADO_INICIO;
    mostrarPantallaConexiones();
  }
}

void procesarComandosTelegram() {
  if (!telegramConnected) return;

  int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  
  if (numNewMessages > 0) {
    necesitaActualizarPantalla = true;
    Serial.println("üéØ Mensajes nuevos detectados - forzando actualizaci√≥n");
  }

  while (numNewMessages) {
    for (int i = 0; i < numNewMessages; i++) {
      String raw_chat_id = bot.messages[i].chat_id;
      String raw_text = bot.messages[i].text;
      
      String text = raw_text;
      text.trim();
      if (!text.startsWith("/")) {
        text = "/" + text;
      }
      text.toLowerCase();

      // ACEPTAR CUALQUIER CHAT (para pruebas)
      bool aceptarCualquierChat = true;
      bool mismo_chat = aceptarCualquierChat;

      if (!mismo_chat) {
        Serial.println("‚ö†Ô∏è Mensaje ignorado: chat distinto.");
        continue;
      }

      // ACK autom√°tico
      if (telegramConnected) {
        String ack = "‚úÖ Recibido: " + raw_text;
        bot.sendMessage(raw_chat_id, ack, "");
      }

      // COMANDOS (igual que en versi√≥n Wokwi)
      if (text == "/start" || text == "/help") {
        String welcome = "üéÆ *Quiz ESP32 - Comandos disponibles:*\n";
        welcome += "/seleccionar_partida 1vs1\n";
        welcome += "/seleccionar_partida ranking\n";
        welcome += "/seleccionar_partida multijugador\n";
        welcome += "/iniciar_partida\n";
        welcome += "/ingresar_usuario NOMBRE\n";
        welcome += "/ranking\n";
        welcome += "/estado\n";
        bot.sendMessage(raw_chat_id, welcome, "Markdown");
      }
      else if (text == "/estado") {
        String estado = "üìä *Estado Actual:*\n";
        estado += "Modo: " + (modoPartida == "" ? "No seleccionado" : modoPartida) + "\n";
        estado += "Estado: ";
        switch (estadoActual) {
          case ESTADO_INICIO: estado += "Inicio"; break;
          case ESTADO_SELECCION_MODO: estado += "Seleccionando modo"; break;
          case ESTADO_SELECCION_USUARIO: estado += "Seleccionando usuario"; break;
          case ESTADO_JUGANDO: estado += "Jugando"; break;
          case ESTADO_FINAL: estado += "Finalizado"; break;
        }
        estado += "\nPregunta: " + String(preguntaActual + 1) + "/" + String(totalPreguntas);
        estado += "\nPuntuaci√≥n: " + String(puntuacionTotal);
        estado += "\nUsuario: " + (usuarioActual >= 0 ? usuarios[usuarioActual].nombre : "No seleccionado");
        bot.sendMessage(raw_chat_id, estado, "Markdown");
      }
      else if (text == "/ranking") {
        String rankingMsg = "üèÜ *Ranking Actual:*\n";
        if (totalUsuarios == 0) {
          rankingMsg += "No hay usuarios registrados";
        } else {
          for (int k = 0; k < (totalUsuarios < 5 ? totalUsuarios : 5); k++) {
            rankingMsg += String(k + 1) + ". " + usuarios[k].nombre + " - " + String(usuarios[k].puntuacionMaxima) + " pts\n";
          }
        }
        bot.sendMessage(raw_chat_id, rankingMsg, "Markdown");
      }
      else if (text.startsWith("/seleccionar_partida")) {
        String modo = text.substring(String("/seleccionar_partida").length());
        modo.trim();
        modo.toLowerCase();

        if (modo.length() == 0) {
          String ayuda = "üéÆ *Selecciona modo de partida:*\n";
          ayuda += "/seleccionar_partida 1vs1\n";
          ayuda += "/seleccionar_partida ranking\n";
          ayuda += "/seleccionar_partida multijugador";
          bot.sendMessage(raw_chat_id, ayuda, "Markdown");
        }
        else if (modo == "1vs1" || modo == "ranking" || modo == "multijugador") {
          modoPartida = modo;
          bot.sendMessage(raw_chat_id, "‚úÖ Modo seleccionado: *" + modo + "*", "Markdown");
          
          estadoActual = ESTADO_SELECCION_USUARIO;
          opcionSeleccionada = 0;
          necesitaActualizarPantalla = true;
        }
        else {
          bot.sendMessage(raw_chat_id, "‚ùå Modos v√°lidos: 1vs1, ranking, multijugador", "Markdown");
        }
      }
      else if (text == "/iniciar_partida") {
        if (modoPartida == "") {
          bot.sendMessage(raw_chat_id, "‚ùå Primero selecciona un modo con /seleccionar_partida", "Markdown");
        }
        else if (estadoActual != ESTADO_JUGANDO && estadoActual != ESTADO_FINAL) {
          bot.sendMessage(raw_chat_id, "üéÆ Iniciando partida en modo: *" + modoPartida + "*", "Markdown");
          iniciarJuego();
        }
        else {
          bot.sendMessage(raw_chat_id, "‚ö†Ô∏è El juego ya est√° en curso", "Markdown");
        }
      }
      else if (text.startsWith("/ingresar_usuario")) {
        String nombre = text.substring(String("/ingresar_usuario").length());
        nombre.trim();
        if (nombre.length() == 0) {
          bot.sendMessage(raw_chat_id, "‚ùå Ingresa un nombre: /ingresar_usuario Sofi", "Markdown");
        } else {
          nombre.toUpperCase();
          int usuarioExistente = buscarUsuario(nombre);

          if (usuarioExistente == -1) {
            agregarUsuario(nombre, true, true);
            bot.sendMessage(raw_chat_id, "‚úÖ Usuario registrado: *" + nombre + "*", "Markdown");
            
            usuarioActual = buscarUsuario(nombre);
            opcionSeleccionada = usuarioActual >= 0 ? usuarioActual : 0;
            
            if (modoPartida == "1vs1") {
              estadoActual = ESTADO_SELECCION_OPONENTE;
              opcionSeleccionada = (usuarioActual == 0 && totalUsuarios>1) ? 1 : 0;
            } else {
              estadoActual = ESTADO_ESPERA_INICIO;
            }
            necesitaActualizarPantalla = true;
            
            bot.sendMessage(raw_chat_id, "‚úÖ Usuario creado: *" + nombre + "*. Gira el encoder o usa /iniciar_partida para comenzar.", "Markdown");
          }
          else {
            usuarioActual = usuarioExistente;
            bot.sendMessage(raw_chat_id, "‚úÖ Usuario seleccionado: *" + nombre + "*", "Markdown");
            
            estadoActual = ESTADO_ESPERA_INICIO;
            opcionSeleccionada = usuarioActual;
            necesitaActualizarPantalla = true;

            if (modoPartida != "") {
              bot.sendMessage(raw_chat_id, "üéÆ Iniciando partida autom√°ticamente...", "Markdown");
              iniciarJuego();
            }
          }
        }
      }
      else {
        bot.sendMessage(raw_chat_id, "‚ùì Comando no reconocido. Usa /help para ver comandos.", "Markdown");
      }
    }
    
    numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    if (numNewMessages > 0) {
      necesitaActualizarPantalla = true;
    }
  }
}

// ==================== FUNCIONES DE USUARIOS ====================

int buscarUsuario(String nombre) {
  for(int i = 0; i < totalUsuarios; i++) {
    if(usuarios[i].nombre == nombre) {
      return i;
    }
  }
  return -1;
}

void agregarUsuario(String nombre, bool setAsCurrent = true, bool notify = true) {
  if(totalUsuarios < 100) {
    usuarios[totalUsuarios].nombre = nombre;
    usuarios[totalUsuarios].puntuacionMaxima = 0;
    usuarios[totalUsuarios].partidasJugadas = 0;
    usuarios[totalUsuarios].ultimaPartida = time(nullptr);
    
    if (setAsCurrent) {
      usuarioActual = totalUsuarios;
    }
    
    totalUsuarios++;
    guardarUsuarios();
    
    Serial.println("Nuevo usuario creado: " + nombre);
    
    if (notify && telegramConnected) {
      bot.sendMessage(CHAT_ID, "üë§ Nuevo usuario registrado: *" + nombre + "*", "Markdown");
    }
  }
}

void actualizarPuntuacionUsuario() {
  if(usuarioActual >= 0) {
    usuarios[usuarioActual].partidasJugadas++;
    usuarios[usuarioActual].ultimaPartida = time(nullptr);
    
    if(puntuacionTotal > usuarios[usuarioActual].puntuacionMaxima) {
      usuarios[usuarioActual].puntuacionMaxima = puntuacionTotal;
    }
    
    guardarUsuarios();
    
    Serial.println("Usuario " + usuarios[usuarioActual].nombre + 
                  " actualizado. Max: " + usuarios[usuarioActual].puntuacionMaxima +
                  " Partidas: " + usuarios[usuarioActual].partidasJugadas);
                  
    if (telegramConnected) {
      String msg = "üèÜ *Actualizaci√≥n de Usuario:*\n";
      msg += "Jugador: " + usuarios[usuarioActual].nombre + "\n";
      msg += "Puntuaci√≥n m√°xima: " + String(usuarios[usuarioActual].puntuacionMaxima) + "\n";
      msg += "Partidas jugadas: " + String(usuarios[usuarioActual].partidasJugadas);
      bot.sendMessage(CHAT_ID, msg, "Markdown");
    }
  }
}

// ==================== FUNCIONES DE PANTALLA ====================

void mostrarPantallaConexiones() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("‚úÖ SISTEMA LISTO");
  display.setCursor(0, 12);
  display.println("WiFi: CONECTADO");
  display.setCursor(0, 24);
  display.println("Telegram: OK");
  display.setCursor(0, 36);
  display.println("SPIFFS: ACTIVO");
  display.setCursor(0, 48);
  display.println("Usa Telegram:");
  display.setCursor(0, 56);
  display.println("/ingresar_usuario");
  display.display();
}

void mostrarPantallaSeleccionModo() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("SELECCIONA MODO:");

  String opciones[] = {"1vs1", "Ranking", "Multijugador"};
  for (int i = 0; i < 3; i++) {
    display.setCursor(5, 15 + i * 12);
    if (i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.println(opciones[i]);
  }

  display.setCursor(0, 55);
  display.println("Click: Seleccionar");
  display.display();
}

void mostrarPantallaSeleccionUsuario() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("SELECCIONA USUARIO:");

  if (totalUsuarios == 0) {
    display.setCursor(5, 20);
    display.println("No hay usuarios");
    display.setCursor(5, 32);
    display.println("Usa Telegram:");
    display.setCursor(5, 44);
    display.println("/ingresar_usuario");
    display.setCursor(5, 56);
    display.println("para crear uno");
  } else {
    for (int i = 0; i < min(4, totalUsuarios); i++) {
      display.setCursor(5, 15 + i * 12);
      if (i == opcionSeleccionada) {
        display.print("> ");
      } else {
        display.print("  ");
      }
      display.println(usuarios[i].nombre);
    }

    display.setCursor(0, 55);
    display.println("Click: Seleccionar");
  }
  display.display();
}

void mostrarPantallaEsperaInicio() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("LISTO PARA INICIAR");
  display.setCursor(0, 12);
  if (usuarioActual >= 0) {
    display.print("Jugador: ");
    display.println(usuarios[usuarioActual].nombre);
  }
  display.setCursor(0, 28);
  display.println("Gira el encoder ->");
  display.setCursor(0, 40);
  display.println("o /iniciar_partida");
  display.setCursor(0, 56);
  if (modoPartida == "1vs1") {
    display.println("Click: Seleccionar oponente");
  } else {
    display.println("Click: Iniciar");
  }
  display.display();
}

void mostrarPantallaSeleccionOponente() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("SELECC. OPONENTE:");

  if (totalUsuarios <= 1) {
    display.setCursor(5, 20);
    display.println("No hay otros usuarios");
    display.setCursor(5, 36);
    display.println("Crea mas en Telegram");
    display.setCursor(5, 56);
    display.println("Click: Volver");
    display.display();
    return;
  }

  int mostrarIdx = 0;
  for (int i = 0; i < totalUsuarios && mostrarIdx < 4; i++) {
    if (i == usuarioActual) continue;

    display.setCursor(5, 15 + mostrarIdx * 12);
    if (i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.println(usuarios[i].nombre);
    mostrarIdx++;
  }

  display.setCursor(0, 55);
  display.println("Click: Seleccionar");
  display.display();
}

void mostrarPregunta() {
  display.clearDisplay();

  display.setCursor(0, 0);
  if (usuarioActual >= 0) {
    display.print(usuarios[usuarioActual].nombre);
  }
  if (modoPartida == "1vs1" && oponenteActual >= 0) {
    display.setCursor(70, 0);
    display.print("VS:");
    display.setCursor(88, 0);
    display.print(usuarios[oponenteActual].nombre);
  } else {
    display.print("JUGADOR");
  }
  display.setCursor(70, 0);
  display.print(preguntaActual + 1);
  display.print("/");
  display.print(totalPreguntas);
  display.setCursor(100, 0);
  display.print(puntuacionTotal);

  mostrarTextoEnLineas(limpiarTexto(preguntas[preguntaActual].texto), 0, 12, 128);

  for (int i = 0; i < 3; i++) {
    display.setCursor(5, 25 + i * 12);
    if (i == opcionSeleccionada) {
      display.print("> ");
    } else {
      display.print("  ");
    }
    display.println(preguntas[preguntaActual].opciones[i]);
  }

  display.display();
}

void mostrarResultado() {
  display.clearDisplay();
  display.setCursor(20, 10);
  display.println("QUIZ COMPLETADO!");
  display.setCursor(10, 25);
  if (usuarioActual >= 0) {
    display.print("Jugador: ");
    display.println(usuarios[usuarioActual].nombre);
  }
  display.setCursor(30, 40);
  display.print("Puntos: ");
  display.println(puntuacionTotal);

  if (modoPartida == "1vs1" && oponenteActual >= 0) {
    display.setCursor(0, 50);
    String s = "VS "; s += usuarios[oponenteActual].nombre;
    display.println(s);
    display.setCursor(80, 50);
    display.print("O: "); display.print(usuarios[oponenteActual].puntuacionMaxima);
  }
  display.setCursor(5, 55);
  display.println("Click para reiniciar");
  display.display();
}

void actualizarPantallaSegunEstado() {
  Serial.print("üîÑ Actualizando pantalla forzada - Estado: ");
  Serial.println(estadoActual);
  
  switch(estadoActual) {
    case ESTADO_INICIO:
      mostrarPantallaConexiones();
      break;
    case ESTADO_SELECCION_MODO:
      mostrarPantallaSeleccionModo();
      break;
    case ESTADO_SELECCION_USUARIO:
      mostrarPantallaSeleccionUsuario();
      break;
    case ESTADO_ESPERA_INICIO:
      mostrarPantallaEsperaInicio();
      break;
    case ESTADO_SELECCION_OPONENTE:
      mostrarPantallaSeleccionOponente();
      break;
    case ESTADO_JUGANDO:
      mostrarPregunta();
      break;
    case ESTADO_FINAL:
      mostrarResultado();
      break;
  }
  necesitaActualizarPantalla = false;
}

// ==================== FUNCIONES DEL QUIZ ====================

void mostrarTextoEnLineas(String texto, int x, int y, int anchoMax) {
  int inicio = 0;
  int fin = anchoMax / 6;

  while (inicio < texto.length()) {
    if (fin > texto.length()) fin = texto.length();

    int ultimoEspacio = texto.lastIndexOf(' ', fin);
    if (ultimoEspacio == -1 || ultimoEspacio <= inicio) ultimoEspacio = fin;

    display.setCursor(x, y);
    display.println(texto.substring(inicio, ultimoEspacio));

    y += 10;
    inicio = ultimoEspacio + 1;
    fin = inicio + (anchoMax / 6);
  }
}

String limpiarTexto(String texto) {
  texto.replace("√°", "a");
  texto.replace("√©", "e");
  texto.replace("√≠", "i");
  texto.replace("√≥", "o");
  texto.replace("√∫", "u");
  texto.replace("√±", "n");
  texto.replace("¬ø", "?");
  texto.replace("¬°", "!");
  return texto;
}

void verificarRespuesta() {
  bool correcta = (opcionSeleccionada == preguntas[preguntaActual].respuestaCorrecta);

  display.clearDisplay();
  display.setCursor(0, 0);
  display.println(preguntas[preguntaActual].texto);
  display.setCursor(0, 15);
  display.print("Elegiste: ");
  display.println(preguntas[preguntaActual].opciones[opcionSeleccionada]);

  if (correcta) {
    puntuacionTotal += preguntas[preguntaActual].puntaje;
    display.setCursor(0, 30);
    display.print("CORRECTO! +");
    display.print(preguntas[preguntaActual].puntaje);
    digitalWrite(LED_PIN, HIGH);

    if (telegramConnected) {
      bot.sendMessage(CHAT_ID, "‚úÖ ¬°Respuesta correcta! +" + String(preguntas[preguntaActual].puntaje) + " puntos", "");
    }
  } else {
    display.setCursor(0, 30);
    display.println("INCORRECTO");
    display.setCursor(0, 45);
    display.print("Correcta: ");
    display.println(preguntas[preguntaActual].opciones[preguntas[preguntaActual].respuestaCorrecta]);

    if (telegramConnected) {
      bot.sendMessage(CHAT_ID, "‚ùå Respuesta incorrecta. La correcta era: " + preguntas[preguntaActual].opciones[preguntas[preguntaActual].respuestaCorrecta], "");
    }
  }

  display.display();
  delay(1500);
  digitalWrite(LED_PIN, LOW);

  preguntaActual++;
  if (preguntaActual >= totalPreguntas) {
    quizCompletado = true;
    actualizarPuntuacionUsuario();
    estadoActual = ESTADO_FINAL;
    mostrarResultado();

    if (telegramConnected) {
      String resultado = "üèÅ *QUIZ COMPLETADO!*\n";
      resultado += "Jugador: " + (usuarioActual >= 0 ? usuarios[usuarioActual].nombre : "An√≥nimo") + "\n";
      resultado += "Puntuaci√≥n final: *" + String(puntuacionTotal) + "* puntos\n";
      resultado += "Modo de juego: " + modoPartida;
      bot.sendMessage(CHAT_ID, resultado, "Markdown");
    }
  } else {
    opcionSeleccionada = 0;
    mostrarPregunta();
  }
}

void iniciarJuego() {
  Serial.println("=== üéÆ INICIAR JUEGO ===");
  
  if (usuarioActual < 0 || usuarioActual >= totalUsuarios) {
    Serial.println("‚ùå ERROR: No hay usuario seleccionado v√°lido");
    return;
  }
  
  if (modoPartida == "") {
    Serial.println("‚ùå ERROR: No hay modo seleccionado");
    return;
  }
  
  Serial.print("Jugador: ");
  Serial.println(usuarios[usuarioActual].nombre);
  Serial.print("Modo: ");
  Serial.println(modoPartida);
  
  quizIniciado = true;
  quizCompletado = false;
  preguntaActual = 0;
  opcionSeleccionada = 0;
  puntuacionTotal = 0;
  estadoActual = ESTADO_JUGANDO;
  
  if (telegramConnected) {
    String mensaje = "üéÆ Partida iniciada!\n";
    mensaje += "Jugador: *" + usuarios[usuarioActual].nombre + "*\n";
    mensaje += "Modo: *" + modoPartida + "*";
    if (modoPartida == "1vs1" && oponenteActual >= 0) {
      mensaje += "\nOponente: *" + usuarios[oponenteActual].nombre + "*";
    }
    bot.sendMessage(CHAT_ID, mensaje, "Markdown");
  }
  
  mostrarPregunta();
  Serial.println("‚úÖ Juego iniciado correctamente");
}

void reiniciarQuiz() {
  preguntaActual = 0;
  opcionSeleccionada = 0;
  puntuacionTotal = 0;
  quizCompletado = false;
  quizIniciado = false;
  estadoActual = ESTADO_INICIO;

  mostrarPantallaConexiones();

  if (telegramConnected) {
    bot.sendMessage(CHAT_ID, "üîÑ Quiz reiniciado. Listo para nueva partida", "");
  }
}

// ==================== SETUP Y LOOP ====================

void setup() {
  Serial.begin(9600);
  Serial.println("Terminal abierta");
  
  pinMode(LED_PIN, OUTPUT);
  pinMode(ENCODER_CLK, INPUT_PULLUP);
  pinMode(ENCODER_DT, INPUT_PULLUP);
  pinMode(ENCODER_SW, INPUT_PULLUP);
  
  display.begin(0x3c, true);
  display.setTextSize(1);
  display.setTextColor(SH110X_WHITE);
  display.clearDisplay();
  
  // Inicializar sistema de archivos
  if(!inicializarSPIFFS()) {
    Serial.println("Fallo en SPIFFS");
  }
  
  // Cargar datos
  if(!cargarPreguntas()) {
    Serial.println("Usando preguntas por defecto");
  }
  
  if(!cargarUsuarios()) {
    Serial.println("Error cargando usuarios");
  }
  
  configTime(0, 0, "pool.ntp.org");
  
  // Conectar a Telegram
  conectarTelegram();
  
  Serial.println("üöÄ Sistema listo con Telegram y SPIFFS");
}

void loop() {
  // Procesar Telegram frecuentemente
  if (millis() > lastTimeBotRan + 100) {
    procesarComandosTelegram();
    lastTimeBotRan = millis();
  }

  // Verificar actualizaciones de pantalla
  if (necesitaActualizarPantalla && (millis() - ultimaActualizacionPantalla > INTERVALO_ACTUALIZACION)) {
    actualizarPantallaSegunEstado();
    ultimaActualizacionPantalla = millis();
  }

  // Manejar encoder
  handleEncoderWokwi();

  // Manejar bot√≥n
  if (buttonPressedWokwi()) {
    switch(estadoActual) {
      case ESTADO_SELECCION_MODO: {
        String modos[] = {"1vs1", "ranking", "multijugador"};
        modoPartida = modos[opcionSeleccionada];
        estadoActual = ESTADO_SELECCION_USUARIO;
        opcionSeleccionada = 0;
        necesitaActualizarPantalla = true;
        break;
      }
      
      case ESTADO_SELECCION_USUARIO:
        if (totalUsuarios > 0) {
          usuarioActual = opcionSeleccionada;
          estadoActual = ESTADO_ESPERA_INICIO;
          necesitaActualizarPantalla = true;
        }
        break;
      
      case ESTADO_ESPERA_INICIO:
        if (modoPartida == "1vs1") {
          estadoActual = ESTADO_SELECCION_OPONENTE;
          opcionSeleccionada = (usuarioActual == 0 && totalUsuarios>1) ? 1 : 0;
          necesitaActualizarPantalla = true;
        } else {
          iniciarJuego();
        }
        break;
      
      case ESTADO_SELECCION_OPONENTE:
        if (totalUsuarios > 1) {
          oponenteActual = opcionSeleccionada;
          iniciarJuego();
        }
        break;
      
      case ESTADO_JUGANDO:
        verificarRespuesta();
        break;
      
      case ESTADO_FINAL:
        reiniciarQuiz();
        break;
    }
  }
}


averigur sobre un certificado ?